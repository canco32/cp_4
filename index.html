<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Drag and Drop Network App</title>
  <script src="https://cdn.jsdelivr.net/npm/alpinejs@3.12.0/dist/cdn.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/interact.js/1.10.11/interact.min.js"></script>
  <script src="https://cdn.tailwindcss.com"></script>
  <link rel="stylesheet" href="style.css">
</head>
<body class="bg-gray-100 flex items-center justify-center min-h-screen">
  <div class="bg-white shadow-lg p-5 rounded-lg w-full">
    <h1 class="text-2xl font-bold mb-5">Network Design Tool</h1>

    <div class="flex space-x-4 mb-5">
      <button id="add-router" class="px-4 py-2 bg-blue-500 text-white rounded shadow">Add Router</button>
      <button id="add-workstation" class="px-4 py-2 bg-green-500 text-white rounded shadow">Add Workstation</button>
      <button id="add-wire" class="px-4 py-2 bg-gray-500 text-white rounded shadow">Add Wire</button>
      <button id="randomize" class="px-4 py-2 bg-purple-500 text-white rounded shadow">Randomize</button>
      <button id="transfer-data" class="px-4 py-2 bg-blue-500 text-white rounded shadow">Transfer data</button>
      <button id="remove-wire" class="px-4 py-2 bg-red-500 text-white rounded shadow">Remove Wire</button>
      <button id="remove-object" class="px-4 py-2 bg-red-500 text-white rounded shadow">Remove object</button>
      <button id="download-config" class="px-4 py-2 bg-blue-500 text-white rounded shadow">Download Configuration</button>
      <div id="upload-config">
        
      </div>
    </div>

    <div id="canvas-container" class="relative bg-white border border-gray-400 rounded overflow-hidden" style="width: 100%; height: 1400px;">
      <div id="canvas" class="absolute top-0 left-0 w-full h-full">
      </div>
    </div>
    <div id="table" class="bg-white mt-4"></div>
  </div>

  <script type="module" src="model/index.js"></script>


<script>

// class PacketTransfer {
//     constructor(networkConfig) {
//         this.networkConfig = networkConfig; // Содержит объекты и соединения из JSON
//         this.graph = this.buildGraph();
//         this.highlightedElements = new Set(); // Хранит подсвеченные элементы
//         this.packets = []; // Массив для хранения всех пакетов
//     }

//     // Строим граф из данных JSON
//     buildGraph() {
//         const graph = {};

//         // Добавляем объекты в граф
//         this.networkConfig.objects.forEach(obj => {
//             graph[obj.id] = { 
//                 neighbors: [],
//                 objectStatus: obj.objectStatus
//             };
//         });

//         // Добавляем связи (провода) в граф
//         this.networkConfig.wires.forEach(wire => {
//             const startNode = wire.startId;
//             const endNode = wire.endId;
//             const weight = parseFloat(wire.weight);
//             const transmissionType = wire.transmissionType;
//             const objectStatus = wire.objectStatus;

//             // Добавляем двустороннее соединение в граф (если оно активно)
//             if (objectStatus === 'on') {
//                 graph[startNode].neighbors.push({ id: endNode, weight, transmissionType, objectStatus });
//                 graph[endNode].neighbors.push({ id: startNode, weight, transmissionType, objectStatus });
//             }
//         });

//         return graph;
//     }

//     // Применяем алгоритм Дейкстра для поиска кратчайшего пути к каждому узлу
//     dijkstraAll(startId) {
//         const distances = {};
//         const previousNodes = {};
//         const unvisitedNodes = new Set(Object.keys(this.graph));

//         // Инициализируем расстояния
//         unvisitedNodes.forEach(node => {
//             distances[node] = node === startId ? 0 : Infinity;
//             previousNodes[node] = null;
//         });

//         while (unvisitedNodes.size > 0) {
//             // Найдем узел с минимальным расстоянием
//             let currentNode = null;
//             unvisitedNodes.forEach(node => {
//                 if (currentNode === null || distances[node] < distances[currentNode]) {
//                     currentNode = node;
//                 }
//             });

//             if (distances[currentNode] === Infinity) break; // Если расстояние бесконечность, путь недостижим

//             // Проверяем соседей текущего узла
//             this.graph[currentNode].neighbors.forEach(neighbor => {
//                 if (unvisitedNodes.has(neighbor.id) && this.graph[neighbor.id].objectStatus === 'on') {
//                     const alt = distances[currentNode] + neighbor.weight;
//                     if (alt < distances[neighbor.id]) {
//                         distances[neighbor.id] = alt;
//                         previousNodes[neighbor.id] = currentNode;
//                     }
//                 }
//             });

//             // Убираем текущий узел из множества не посещенных
//             unvisitedNodes.delete(currentNode);
//         }

//         // Составляем таблицы расстояний и маршрутов
//         const routes = {};
//         Object.keys(this.graph).forEach(node => {
//             const path = [];
//             let currentNode = node;
//             while (previousNodes[currentNode]) {
//                 path.unshift(currentNode);
//                 currentNode = previousNodes[currentNode];
//             }
//             if (distances[node] !== Infinity && node !== startId) {
//                 path.unshift(startId);
//             }
//             routes[node] = { distance: distances[node], path: path.length > 1 ? path : null };
//         });

//         return routes;
//     }

//     displayWorkstationRoutingTable(startId) {
//         const tableDiv = document.getElementById('table');
//         tableDiv.innerHTML = ''; // Очистить перед добавлением новой таблицы

//         const routes = this.dijkstraAll(startId);

//         const table = document.createElement('table');
//         table.classList.add('table', 'border', 'border-collapse', 'w-full');

//         const headerRow = document.createElement('tr');
//         headerRow.innerHTML = `
//             <th class="border px-4 py-2">Target Workstation</th>
//             <th class="border px-4 py-2">Distance</th>
//             <th class="border px-4 py-2">Path</th>
//         `;
//         table.appendChild(headerRow);

//         Object.entries(routes).forEach(([target, data]) => {
//             // Фильтруем только рабочие станции (id начинается с 'workstation-')
//             if (target.startsWith('workstation-') && target !== startId) {
//                 const row = document.createElement('tr');
//                 row.innerHTML = `
//                     <td class="border px-4 py-2">${target}</td>
//                     <td class="border px-4 py-2">${data.distance === Infinity ? 'Unreachable' : data.distance}</td>
//                     <td class="border px-4 py-2">${data.path ? data.path.join(' -> ') : 'N/A'}</td>
//                 `;
//                 table.appendChild(row);
//             }
//         });

//         tableDiv.appendChild(table);
//     }

//     dijkstra(startId, endId) {
//         const distances = {};
//         const previousNodes = {};
//         const unvisitedNodes = new Set(Object.keys(this.graph));

//         // Инициализируем расстояния
//         unvisitedNodes.forEach(node => {
//             distances[node] = node === startId ? 0 : Infinity;
//             previousNodes[node] = null;
//         });

//         while (unvisitedNodes.size > 0) {
//             // Найдем узел с минимальным расстоянием
//             let currentNode = null;
//             unvisitedNodes.forEach(node => {
//                 if (currentNode === null || distances[node] < distances[currentNode]) {
//                     currentNode = node;
//                 }
//             });

//             if (distances[currentNode] === Infinity) break; // Если расстояние бесконечность, путь недостижим

//             // Проверяем соседей текущего узла
//             this.graph[currentNode].neighbors.forEach(neighbor => {
//                 if (unvisitedNodes.has(neighbor.id) && this.graph[neighbor.id].objectStatus === 'on') {
//                     const alt = distances[currentNode] + neighbor.weight;
//                     if (alt < distances[neighbor.id]) {
//                         distances[neighbor.id] = alt;
//                         previousNodes[neighbor.id] = currentNode;
//                     }
//                 }
//             });

//             // Убираем текущий узел из множества не посещенных
//             unvisitedNodes.delete(currentNode);
//         }

//         // Восстановим путь
//         const path = [];
//         let currentNode = endId;
//         while (previousNodes[currentNode]) {
//             path.unshift(currentNode);
//             currentNode = previousNodes[currentNode];
//         }

//         if (distances[endId] === Infinity) {
//             return null; // Путь не найден
//         }

//         path.unshift(startId); // Добавляем начальную станцию
//         return path;
//     }

//     // Подсвечивает элементы на пути
//     highlightPath(path) {
//         this.clearHighlights();

//         path.forEach((stationId, index) => {
//             const element = document.querySelector(`[data-id="${stationId}"]`);
//             if (element) {
//                 element.classList.add('highlight');
//                 this.highlightedElements.add(element);
//             }

//             if (index < path.length - 1) {
//                 const nextStationId = path[index + 1];
//                 const cable = this.networkConfig.wires.find(wire => 
//                     (wire.startId === stationId && wire.endId === nextStationId && wire.objectStatus === 'on') ||
//                     (wire.startId === nextStationId && wire.endId === stationId && wire.objectStatus === 'on')
//                 );
//                 if (cable) {
//                     const cableElement = document.querySelector(`[data-id="${cable.id}"]`);
//                     if (cableElement) {
//                         cableElement.classList.add('highlight');
//                         this.highlightedElements.add(cableElement);
//                     }
//                 }
//             }
//         });
//     }

//     // Снимает подсветку со всех элементов
//     clearHighlights() {
//         document.querySelectorAll('.highlight').forEach(element => {
//             element.classList.remove('highlight');
//         });
//         this.highlightedElements.clear();
//     }

//     getPathDetails(path) {
//         const details = [];

//         path.forEach((stationId, index) => {
//             if (index < path.length - 1) {
//                 const nextStationId = path[index + 1];
//                 // Ищем кабель, соединяющий текущую станцию и следующую
//                 const cable = this.networkConfig.wires.find(wire => 
//                     (wire.startId === stationId && wire.endId === nextStationId && wire.objectStatus === 'on') ||
//                     (wire.startId === nextStationId && wire.endId === stationId && wire.objectStatus === 'on')
//                 );

//                 if (cable) {
//                     // Добавляем информацию о кабеле в детали
//                     details.push({
//                         id: cable.id,
//                         startId: cable.startId,
//                         endId: cable.endId,
//                         cableType: cable.cableType,
//                         transmissionType: cable.transmissionType,
//                         weight: cable.weight,
//                         objectStatus: cable.objectStatus
//                     });
//                 }
//             }
//         });

//         return {
//             path, // Массив с последовательностью узлов
//             details // Массив с деталями кабелей
//         };
//     }

//     calculateTransmissionDetails(pathDetails) {
//         let totalTransmissionTime = 0;
//         let lossProbability = 0;

//         pathDetails.details.forEach(connection => {
//             let connectionTime = parseFloat(connection.weight);

//             // Учитываем тип кабеля
//             if (connection.cableType === "satellite") {
//                 connectionTime += 20; // Дополнительная задержка для спутникового канала
//                 lossProbability += 0.05; // Увеличиваем вероятность потери для спутникового канала
//             } else {
//                 // Обычный кабель
//                 lossProbability += 0.03;
//             }

//             // Учитываем тип передачи
//             if (connection.transmissionType === "halfduplex") {
//                 connectionTime += 15;
//                 lossProbability += 0.04;
//             } else if (connection.transmissionType === "duplex") {
//                 connectionTime += 5;
//                 lossProbability += 0.02;
//             }

//             totalTransmissionTime += connectionTime;
//         });

//         // Приводим вероятность к диапазону [0, 1]
//         lossProbability = Math.min(1, lossProbability);

//         return {
//             totalTransmissionTime,
//             lossProbability
//         };
//     }

//     tcpTransferSimulation(path, dataSize) {
//         const controlPackets = 5; // TCP: SYN, SYN-ACK, ACK для установки соединения, FIN, FIN-ACK для закрытия
//         const retransmissionPenalty = 100; // Дополнительная задержка при потере пакета (мс)
//         const headerSize = 40; // 16 байт IP + 24 байта TCP заголовка
//         const maxPacketSize = 1500; // Максимальный размер TCP пакета (в байтах)
//         const dataPayloadSize = maxPacketSize - headerSize; // Размер данных в одном пакете

//         // Проверяем, передан ли корректный размер данных
//         if (!dataSize || isNaN(dataSize)) {
//             console.error("Invalid dataSize provided.");
//             return;
//         }

//         // Получаем детали маршрута
//         const pathDetails = this.getPathDetails(path);
//         const transmissionDetails = this.calculateTransmissionDetails(pathDetails);

//         const adaptiveRetransmissionChance = transmissionDetails.lossProbability;
//         const adaptiveFixedDelay = transmissionDetails.totalTransmissionTime;

//         // Вычисляем количество информационных пакетов
//         const dataPackets = Math.ceil(dataSize / dataPayloadSize);
//         const tcpPackets = [];
//         let totalTime = 0;
//         let retransmittedPackets = 0;
//         let totalControlPackets = controlPackets; // Учитываем все управляющие пакеты

//         tcpPackets.push({
//             type: "Control",
//             id: "SYN",
//             header: "TCP Header",
//             payload: null,
//             status: "Sent",
//         });
//         tcpPackets.push({
//             type: "Control",
//             id: "SYN-ACK",
//             header: "TCP Header",
//             payload: null,
//             status: "Sent",
//         });
//         tcpPackets.push({
//             type: "Control",
//             id: "ACK",
//             header: "TCP Header",
//             payload: null,
//             status: "Sent",
//         });
//         totalTime += path.length * adaptiveFixedDelay * 3;

//         let remainingData = dataSize;
//         let packetCount = 0;

//         while (remainingData > 0) {
//             const payloadSize = Math.min(dataPayloadSize, remainingData);
//             let isSuccess = false;
//             packetCount++;

//             while (!isSuccess) {
//                 tcpPackets.push({
//                     type: "Data",
//                     id: `Data-${packetCount}`,
//                     header: "TCP Header",
//                     payload: `${payloadSize} bytes`,
//                     status: "Sent",
//                 });

//                 if (Math.random() > adaptiveRetransmissionChance) {
//                     isSuccess = true; // Пакет успешно доставлен
//                     tcpPackets[tcpPackets.length - 1].status = "Delivered";
//                     // Ответ от получателя
//                     tcpPackets.push({
//                         type: "Control",
//                         id: `ACK-${packetCount}`,
//                         header: "TCP Header",
//                         payload: null,
//                         status: "Sent",
//                     });
//                     totalControlPackets++;
//                 } else {
//                     tcpPackets[tcpPackets.length - 1].status = "Lost";
//                     retransmittedPackets++;
//                     totalTime += retransmissionPenalty; // Добавляем задержку за повторную отправку
//                 }
//             }

//             remainingData -= payloadSize;
//             totalTime += path.length * adaptiveFixedDelay;
//         }

//         tcpPackets.push({
//             type: "Control",
//             id: "FIN",
//             header: "TCP Header",
//             payload: null,
//             status: "Sent",
//         });
//         tcpPackets.push({
//             type: "Control",
//             id: "FIN-ACK",
//             header: "TCP Header",
//             payload: null,
//             status: "Sent",
//         });
//         totalControlPackets += 2;
//         totalTime += path.length * adaptiveFixedDelay * 2;

//         console.log("TCP Packet Details:", tcpPackets);

//         // Возвращаем массив пакетов и метаданные
//         return {
//             totalPackets: tcpPackets.length,
//             controlPackets: totalControlPackets,
//             dataPackets: packetCount,
//             retransmittedPackets,
//             totalTime,
//             packetDetails: tcpPackets,
//         };
//     }

//     udpTransferSimulation(path, dataSize) {
//         const headerSize = 28; // 8 байт UDP + 20 байт IP заголовка
//         const maxPacketSize = 1500; // Максимальный размер UDP пакета (в байтах)
//         const dataPayloadSize = maxPacketSize - headerSize; // Размер полезной нагрузки в одном пакете

//         // Проверяем, передан ли корректный размер данных
//         if (!dataSize || isNaN(dataSize)) {
//             console.error("Invalid dataSize provided.");
//             return;
//         }

//         // Получаем детали маршрута
//         const pathDetails = this.getPathDetails(path);
//         const transmissionDetails = this.calculateTransmissionDetails(pathDetails);

//         const adaptiveFixedDelay = transmissionDetails.totalTransmissionTime;
//         const lossProbability = transmissionDetails.lossProbability;

//         // Вычисляем количество информационных пакетов
//         const dataPackets = Math.ceil(dataSize / dataPayloadSize);
//         const udpPackets = [];
//         let totalTime = 0;
//         let lostPackets = 0;

//         let remainingData = dataSize;
//         let packetCount = 0;

//         while (remainingData > 0) {
//             const payloadSize = Math.min(dataPayloadSize, remainingData);
//             packetCount++;

//             const packet = {
//                 type: "Data",
//                 id: `Data-${packetCount}`,
//                 header: "UDP Header",
//                 payload: `${payloadSize} bytes`,
//                 status: Math.random() > lossProbability ? "Delivered" : "Lost",
//             };

//             udpPackets.push(packet);

//             if (packet.status === "Lost") {
//                 lostPackets++;
//             }

//             remainingData -= payloadSize;
//             totalTime += path.length * adaptiveFixedDelay;
//         }

//         console.log("UPD Packet Details:", udpPackets);

//         // Возвращаем массив пакетов и метаданные
//         return {
//             totalPackets: udpPackets.length,
//             dataPackets: packetCount,
//             lostPackets,
//             totalTime,
//             packetDetails: udpPackets,
//         };
//     }

//     transferDataWithProtocols(fromWorkstationId, toWorkstationId, dataSize) {
//         const path = this.dijkstra(fromWorkstationId, toWorkstationId);

//         if (!path) {
//             console.log(`No path found between ${fromWorkstationId} and ${toWorkstationId}`);
//             return;
//         }

//         const resultDiv = document.getElementById('result-transfer-div');
//         resultDiv.innerHTML = ''; // Очистим результат перед выводом

//         const tcp = this.tcpTransferSimulation(path, dataSize);

//         resultDiv.innerHTML = `
//             <br><b>TCP:</b><br>
//             Total Packets Sent: ${tcp.totalPackets}<br>
//             Information Packets: ${tcp.dataPackets}<br>
//             Control Packets: ${tcp.controlPackets}<br>
//             Retransmitted Packets: ${tcp.retransmittedPackets}<br>
//             Total Time: ${tcp.totalTime} ms<br>
//         `;

//         const udp = this.udpTransferSimulation(path, dataSize);

//         resultDiv.innerHTML += `
//             <br><b>UDP:</b><br>
//             Total Packets Sent: ${udp.totalPackets}<br>
//             Information Packets: ${udp.dataPackets}<br>
//             Control Packets: 0<br>
//             Lost Packets: ${udp.lostPackets}<br>
//             Total Time: ${udp.totalTime} ms<br>
//         `;
        

//         // Подсветка маршрута
//         this.highlightPath(path);

//         // Вывод маршрута
//         this.displayWorkstationRoutingTable(fromWorkstationId);

//     }


// }




//     class SideMenu {
//         constructor(container, networkConfig) {
//             this.container = container;
//             this.menu = null;
//             this.transferDataMenu = null;  // Новое меню для передачи данных
//             this.networkConfig = networkConfig;
//         }

//         // Открытие основного меню
//         openMenu(object) {
//             if (this.menu) {
//                 this.updateMenu(object);
//                 this.menu.style.transform = 'translateX(0)'; // Плавно открываем меню
//             } else {
//                 this.createMenu(object);
//             }
//         }

//         // Закрытие основного меню
//         closeMenu() {
//             if (this.menu) {
//                 this.menu.style.transform = 'translateX(100%)'; // Плавно закрываем меню
//             }
//         }

//         // Открытие меню плавно
//         openTransferDataMenu() {
//             if (!this.transferDataMenu) {
//                 this.createTransferDataMenu();
//             }

//             // Применяем анимацию плавного появления
//             this.transferDataMenu.style.transform = 'translateX(0)';
//         }

//         // Закрытие меню плавно
//         closeTransferDataMenu() {
//             if (this.transferDataMenu) {
//                 // Применяем анимацию плавного скрытия
//                 this.transferDataMenu.style.transform = 'translateX(-100%)';
//             }
//         }

//         // Метод для создания основного меню
//         createMenu(object) {
//             this.menu = document.createElement('div');
//             this.menu.classList.add('side-menu', 'fixed', 'top-0', 'right-0', 'z-20', 'w-96', 'h-full', 'bg-white', 'shadow-xl', 'p-6', 'transform', 'translate-x-full');

//             // Добавляем заголовок
//             const title = document.createElement('h2');
//             title.classList.add('text-xl', 'font-semibold');
//             title.innerText = 'Configuration';
//             this.menu.appendChild(title);

//             const details = document.createElement('div');
//             details.classList.add('mt-4');

//             // Проверяем, является ли объект кабелем
//             if (object.classList.contains('wire')) {
//                 // Если это кабель
//                 details.innerHTML = `
//                     <p><strong>ID:</strong> ${object.dataset.id}</p>
//                     <p><strong>Channel Type:</strong> 
//                         <select class="channel-type-select">
//                             <option value="default" ${object.dataset.channelType === 'default' ? 'selected' : ''}>default</option>
//                             <option value="satellite" ${object.dataset.channelType === 'satellite' ? 'selected' : ''}>satellite</option>
//                         </select>
//                     </p>
//                     <p><strong>Transmission Type:</strong> 
//                         <select class="transmission-type-select">
//                             <option value="duplex" ${object.dataset.transmissionType === 'duplex' ? 'selected' : ''}>duplex</option>
//                             <option value="halfduplex" ${object.dataset.transmissionType === 'halfduplex' ? 'selected' : ''}>halfduplex</option>
//                         </select>
//                     </p>
//                     <p><strong>Weight:</strong> ${object.dataset.weight}</p>
//                     <p><strong>X:</strong> ${parseFloat(object.style.left)}px</p>
//                     <p><strong>Y:</strong> ${parseFloat(object.style.top)}px</p>
//                     <p><strong>Status:</strong> <input type="checkbox" class="toggle-status" ${object.dataset.objectStatus === 'off' ? '' : 'checked'} /> Active</p>
//                 `;
//                 details.querySelector('.channel-type-select').addEventListener('change', (e) => this.updateCableType(e, object));
//                 details.querySelector('.transmission-type-select').addEventListener('change', (e) => this.updateTransmissionType(e, object));
//                 details.querySelector('.toggle-status').addEventListener('change', (e) => this.toggleStatus(e, object));

//             } else {
//                 // Если это объект (маршрутизатор или рабочая станция)
//                 details.innerHTML = `
//                     <p><strong>ID:</strong> ${object.dataset.id}</p>
//                     <p><strong>Type:</strong> ${object.dataset.type}</p>
//                     <p><strong>X:</strong> ${parseFloat(object.style.left)}px</p>
//                     <p><strong>Y:</strong> ${parseFloat(object.style.top)}px</p>
//                     <p><strong>Status:</strong> <input type="checkbox" class="toggle-status" ${object.dataset.objectStatus === 'off' ? '' : 'checked'} /> Active</p>
//                 `;
//                 details.querySelector('.toggle-status').addEventListener('change', (e) => this.toggleStatus(e, object));
//             }

//             this.menu.appendChild(details);

//             const closeButton = document.createElement('button');
//             closeButton.classList.add('mt-6', 'py-2', 'px-4', 'bg-blue-500', 'text-white', 'rounded', 'hover:bg-blue-700', 'transition', 'duration-200');
//             closeButton.innerText = 'Close';
//             closeButton.addEventListener('click', () => this.closeMenu());
//             this.menu.appendChild(closeButton);

//             this.container.appendChild(this.menu);
//         }

//         createTransferDataMenu() {
//             // Создаем меню, но сразу не добавляем анимацию
//             this.transferDataMenu = document.createElement('div');
//             this.transferDataMenu.classList.add('side-menu', 'fixed', 'top-0', 'left-0', 'z-20', 'w-96', 'h-full', 'bg-white', 'shadow-xl', 'p-6', 'transform', 'translate-x-full', 'transition-transform', 'duration-300');

//             // Добавляем заголовок
//             const title = document.createElement('h2');
//             title.classList.add('text-xl', 'font-semibold');
//             title.innerText = 'Transfer Data';
//             this.transferDataMenu.appendChild(title);

//             const details = document.createElement('div');
//             details.classList.add('mt-4');

//             // Создаем поле для выбора исходной рабочей станции
//             details.innerHTML += `
//                 <p><strong>From Workstation:</strong>
//                     <select id="from-workstation-select"></select>
//                 </p>
//                 <p><strong>To Workstation:</strong>
//                     <select id="to-workstation-select"></select>
//                 </p>
//                 <p><strong>Data Size:</strong>
//                     <input type="number" id="data-size" value="1500" min="1" max="1500000" />
//                 </p>
//             `;

//             // Заполняем списки выбора рабочими станциями
//             const fromWorkstationSelect = details.querySelector('#from-workstation-select');
//             const toWorkstationSelect = details.querySelector('#to-workstation-select');

//             // Получаем все рабочие станции на полотне
//             const workstations = document.querySelectorAll('[data-type="workstation"]');

//             workstations.forEach(workstation => {
//                 const id = workstation.dataset.id;
//                 const text = workstation.querySelector('.text-xs').innerText; // Получаем текст из span с классом text-xs

//                 const option = document.createElement('option');
//                 option.value = id;
//                 option.innerText = `${text} (${id})`; // Показываем ID и текст из text-xs
//                 fromWorkstationSelect.appendChild(option);

//                 const option2 = option.cloneNode(true); // Клонируем для второго списка
//                 toWorkstationSelect.appendChild(option2);
//             });


//             // Добавляем кнопку Send
//             const sendButton = document.createElement('button');
//             sendButton.classList.add('mt-6', 'py-2', 'px-4', 'bg-green-500', 'text-white', 'rounded', 'hover:bg-green-700', 'transition', 'duration-200');
//             sendButton.innerText = 'Send';
//             sendButton.id = 'send-data-between';
//             details.appendChild(sendButton);

//             const resultBlock = document.createElement('div');
//             resultBlock.id = 'result-transfer-div';

//             this.transferDataMenu.appendChild(details);

//             const closeButton = document.createElement('button');
//             closeButton.classList.add('mt-6', 'py-2', 'px-4', 'bg-blue-500', 'text-white', 'rounded', 'hover:bg-blue-700', 'transition', 'duration-200');
//             closeButton.innerText = 'Close';
//             closeButton.addEventListener('click', () => this.closeTransferDataMenu());
//             this.transferDataMenu.appendChild(closeButton);

//             this.transferDataMenu.appendChild(resultBlock);

//             this.container.appendChild(this.transferDataMenu);
//         }

//         getAllWorkstations() {
//             // Получаем все элементы с атрибутом data-type="workstation"
//             const workstations = document.querySelectorAll('[data-type="workstation"]');
            
//             // Создаем массив для хранения ID рабочих станций
//             const workstationIds = [];
            
//             // Проходим по всем рабочим станциям и добавляем их ID в массив
//             workstations.forEach(workstation => {
//                 workstationIds.push(workstation.dataset.id); // Сохраняем ID
//             });

//             // Возвращаем массив с ID рабочих станций
//             return workstationIds;
//         }

//         updateMenu(object) {
//             const details = this.menu.querySelector('div');
            
//             // Обновляем содержание в зависимости от типа объекта
//             if (object.classList.contains('wire')) {
//                 // Если это кабель
//                 details.innerHTML = ` 
//                     <p><strong>ID:</strong> ${object.dataset.id}</p>
//                     <p><strong>Channel Type:</strong> 
//                         <select class="channel-type-select">
//                             <option value="default" ${object.dataset.channelType === 'default' ? 'selected' : ''}>default</option>
//                             <option value="satellite" ${object.dataset.channelType === 'satellite' ? 'selected' : ''}>satellite</option>
//                         </select>
//                     </p>
//                     <p><strong>Transmission Type:</strong> 
//                         <select class="transmission-type-select">
//                             <option value="duplex" ${object.dataset.transmissionType === 'duplex' ? 'selected' : ''}>duplex</option>
//                             <option value="halfduplex" ${object.dataset.transmissionType === 'halfduplex' ? 'selected' : ''}>halfduplex</option>
//                         </select>
//                     </p>
//                     <p><strong>Weight:</strong> ${object.dataset.weight}</p>
//                     <p><strong>X:</strong> ${parseFloat(object.style.left)}px</p>
//                     <p><strong>Y:</strong> ${parseFloat(object.style.top)}px</p>
//                     <p><strong>Status:</strong> <input type="checkbox" class="toggle-status" ${object.dataset.objectStatus === 'off' ? '' : 'checked'} /> Active</p>`
//                 ;
//                 details.querySelector('.channel-type-select').addEventListener('change', (e) => this.updateCableType(e, object));
//                 details.querySelector('.transmission-type-select').addEventListener('change', (e) => this.updateTransmissionType(e, object));
//                 details.querySelector('.toggle-status').addEventListener('change', (e) => this.toggleStatus(e, object));
//             } else {
//                 // Если это объект (маршрутизатор или рабочая станция)
//                 details.innerHTML = `
//                     <p><strong>ID:</strong> ${object.dataset.id}</p>
//                     <p><strong>Type:</strong> ${object.dataset.type}</p>
//                     <p><strong>X:</strong> ${parseFloat(object.style.left)}px</p>
//                     <p><strong>Y:</strong> ${parseFloat(object.style.top)}px</p>
//                     <p><strong>Status:</strong> <input type="checkbox" class="toggle-status" ${object.dataset.objectStatus === 'off' ? '' : 'checked'} /> Active</p>`
//                 ;
//                 details.querySelector('.toggle-status').addEventListener('change', (e) => this.toggleStatus(e, object));
//             }
//         }

//         // Обновление типа канала кабеля
//         updateCableType(e, object) {
//             object.dataset.channelType = e.target.value;
//         }

//         // Обновление типа передачи кабеля
//         updateTransmissionType(e, object) {
//             object.dataset.transmissionType = e.target.value;
//         }

//         // Обработка изменения состояния (включить/выключить)
//         toggleStatus(e, object) {
//             const isActive = e.target.checked;

//             // Если статус выключен
//             if (isActive) {
//                 object.dataset.objectStatus = 'on'; // Включаем
//                 object.style.opacity = '1'; // Восстанавливаем видимость
//             } else {
//                 object.dataset.objectStatus = 'off'; // Выключаем
//                 object.style.opacity = '0.5'; // Уменьшаем видимость (приглушаем)
//             }
//         }
//     }



//     class WireManager {
//         constructor(canvas, weights) {
//             this.canvas = canvas;
//             this.weights = weights;
//             this.wires = [];
//             this.sideMenu = new SideMenu(document.body);  // Инициализируем боковое меню
//         }

//         isWireExisting(start, end) {
//             return this.wires.some(wire => (wire.start === start && wire.end === end) || (wire.start === end && wire.end === start));
//         }

//         createWire(startElement, endElement, cableType, transmissionType, weight, objectStatus = 'on') {
//             const wire = document.createElement('div');
//             wire.classList.add('wire');
//             wire.start = startElement;
//             wire.end = endElement;


//             wire.dataset.id = this.wires.length; 
//             wire.dataset.channelType = cableType.toLowerCase(); 
//             wire.dataset.transmissionType = transmissionType.toLowerCase();  
//             wire.dataset.weight = weight; 
//             wire.dataset.objectStatus = objectStatus;   

//             wire.style.opacity = (objectStatus === 'off') ? '0.5' : '1';

//             const label = document.createElement('div');
//             label.classList.add('wire-label');
//             wire.label = label;
//             this.canvas.appendChild(label);

//             this.updateWire(wire);
//             this.canvas.appendChild(wire);
//             this.wires.push(wire);

//             const wireId = this.wires.length - 1;

//             // Добавляем обработчик события для двойного клика на кабель
//             wire.addEventListener('dblclick', () => this.sideMenu.openMenu(wire));

//             return {
//                 id: wireId,
//                 cableType: cableType,
//                 transmissionType: transmissionType,
//                 weight: weight,
//                 objectStatus: objectStatus
//             };
//         }

//         updateWire(wire) {
//             const startRect = wire.start.getBoundingClientRect();
//             const endRect = wire.end.getBoundingClientRect();

//             const canvasRect = this.canvas.getBoundingClientRect();

//             const startX = startRect.left + startRect.width / 2 - canvasRect.left;
//             const startY = startRect.top + startRect.height / 2 - canvasRect.top;
//             const endX = endRect.left + endRect.width / 2 - canvasRect.left;
//             const endY = endRect.top + endRect.height / 2 - canvasRect.top;

//             const length = Math.sqrt(Math.pow(endX - startX, 2) + Math.pow(endY - startY, 2));
//             const angle = Math.atan2(endY - startY, endX - startX) * (180 / Math.PI);

//             wire.style.width = `${length}px`;
//             wire.style.transform = `rotate(${angle}deg)`;
//             wire.style.transformOrigin = '0 0';
//             wire.style.left = `${startX}px`;
//             wire.style.top = `${startY}px`;

//             // Получаем вес с учетом типа канала
//             const weight = this.getWeight(length, wire.dataset.channelType);
//             wire.label.innerText = `${weight}`;

//             wire.label.addEventListener('dblclick', () => this.sideMenu.openMenu(wire));

//             const midX = (startX + endX) / 2 + 10;
//             const midY = (startY + endY) / 2 - 15;

//             const offsetX = 15;
//             const offsetY = 0;

//             wire.label.style.left = `${midX + offsetX}px`;
//             wire.label.style.top = `${midY + offsetY}px`;
//         }

//         getWeight(length, channelType) {
//             // Если канал satellite, применяем особую логику
//             if (channelType === 'satellite') {
//                 if (length < 100) return this.weights[6];  // Вес для спутникового канала в зависимости от длины
//                 if (length < 150) return this.weights[7];
//                 if (length < 200) return this.weights[8];
//                 return this.weights[9];  // Для более длинных спутниковых каналов
//             }

//             // Для других типов каналов применяем текущую логику
//             if (length < 100) return this.weights[0];
//             if (length < 150) return this.weights[1];
//             if (length < 200) return this.weights[2];
//             if (length < 300) return this.weights[3];
//             if (length < 400) return this.weights[4];
//             if (length < 500) return this.weights[5];
//             if (length < 600) return this.weights[6];
//             if (length < 700) return this.weights[7];
//             if (length < 800) return this.weights[8];
//             return this.weights[9];
//         }


//         removeWire(wire) {
//             this.canvas.removeChild(wire);
//             this.canvas.removeChild(wire.label);
//             const index = this.wires.indexOf(wire);
//             if (index > -1) {
//                 this.wires.splice(index, 1);
//             }
//         }
//     }


//     class NetworkConfig {
//         constructor() {
//             this.objects = [];
//             this.wires = [];
//         }

//         addObject(type, x, y, uniqueId, objectStatus) {
//             this.objects.push({
//                 type: type,
//                 x: x,
//                 y: y,
//                 id: uniqueId,
//                 objectStatus: objectStatus  // Сохраняем статус
//             });
//         }

//         addWire(wire) {
//             this.wires.push(wire);
//         }

//         exportToJSON() {
//             return JSON.stringify({
//                 objects: this.objects,
//                 wires: this.wires
//             }, null, 2);
//         }

//         static importFromJSON(jsonData) {
//             const data = JSON.parse(jsonData);
//             const config = new NetworkConfig();
//             config.objects = data.objects;
//             config.wires = data.wires;
//             return config;
//         }
//     }

//     class NetworkApp {
//         constructor(canvas, canvasContainer) {
//             this.canvas = canvas;
//             this.canvasContainer = canvasContainer;
//             this.routerCounter = 0;
//             this.workstationCounter = 0;
//             this.elements = [];
//             this.isWireMode = false;
//             this.isRemoveWireMode = false;
//             this.isRemoveObjectMode = false;
//             this.startElement = null;
//             this.endElement = null;
//             this.networkConfig = new NetworkConfig();

//             this.wireManager = new WireManager(canvas, [3, 5, 6, 8, 10, 12, 17, 20, 25, 27]);
//             this.sideMenu = new SideMenu(document.body, this.networkConfig);  // Инициализируем боковое меню
//         }

//         createElement(type, x = null, y = null, id = null, objectStatus = 'on') {
//             const iconMap = {
//                 router: '🛜',
//                 workstation: '💻'
//             };

//             const posX = x ?? this.generateUniquePosition().x;
//             const posY = y ?? this.generateUniquePosition().y;

//             const element = document.createElement('div');
//             element.classList.add('absolute', 'element', 'shadow-lg', 'cursor-move');
//             element.style.width = '70px';
//             element.style.height = '70px';
//             element.style.left = `${posX}px`;
//             element.style.top = `${posY}px`;
//             element.style.backgroundColor = type === 'workstation' ? '#d4f5d4' : 'white';

//             const icon = document.createElement('span');
//             icon.classList.add('text-lg');
//             icon.innerText = iconMap[type];

//             const label = document.createElement('span');
//             label.classList.add('text-xs');

//             // Увеличиваем счётчик и задаем лейбл
//             const counter = ++this[`${type}Counter`];
//             label.innerText = `${counter}`;

//             element.appendChild(icon);
//             element.appendChild(label);
//             this.canvas.appendChild(element);
//             this.elements.push(element);

//             this.makeDraggable(element);

//             // Создаем уникальный ID, начиная с единицы
//             const uniqueId = id || `${type}-${counter}`;
//             element.dataset.id = uniqueId; 
//             element.dataset.type = type;  
//             element.dataset.objectStatus = objectStatus;  

//             // Добавляем обработчик события для двойного клика на объект
//             element.addEventListener('dblclick', () => this.sideMenu.openMenu(element));

//             this.networkConfig.addObject(type, posX, posY, uniqueId);

//             return element;
//         }

//     createWireMode(addWireButton) {
//         if (this.isWireMode) return;
//         this.isWireMode = true;
//         addWireButton.classList.add('button-active');

//         this.boundHandleWireClick = this.handleWireClick.bind(this);
//         this.canvas.addEventListener('click', this.boundHandleWireClick);
//     }

//     handleWireClick(event) {
//         const target = event.target.closest('.element');
//         if (!target) {
//             if (this.startElement) {
//                 this.startElement.classList.remove('highlight');
//                 this.startElement = null;
//             }
//             this.exitWireMode();
//             return;
//         }

//         if (!this.startElement) {
//             this.startElement = target;
//             this.startElement.classList.add('highlight');
//         } else if (target !== this.startElement) {
//             this.endElement = target;

//             if (this.wireManager.isWireExisting(this.startElement, this.endElement)) {
//                 this.startElement.classList.remove('highlight');
//                 this.startElement = null;
//                 this.endElement = null;
//                 return;
//             }

//             const cableType = "default";
//             const transmissionType = "duplex"; 

//             const weight = this.wireManager.getWeight(this.calculateLength(this.startElement, this.endElement));

//             const wire = this.wireManager.createWire(this.startElement, this.endElement, cableType, transmissionType, weight);
//             this.networkConfig.addWire(wire);

//             this.startElement.classList.remove('highlight');
//             this.endElement.classList.remove('highlight');
//             this.startElement = null;
//             this.endElement = null;

//             this.exitWireMode();
//         }
//     }

//         calculateLength(startElement, endElement) {
//             const startRect = startElement.getBoundingClientRect();
//             const endRect = endElement.getBoundingClientRect();

//             return Math.sqrt(
//                 Math.pow(endRect.left - startRect.left, 2) + Math.pow(endRect.top - startRect.top, 2)
//             );
//         }

//         exitWireMode() {
//             this.isWireMode = false;
//             document.getElementById('add-wire').classList.remove('button-active');
//             this.canvas.removeEventListener('click', this.boundHandleWireClick);
//             this.boundHandleWireClick = null;
//             this.startElement = null;
//             this.endElement = null;
//         }

//         createRemoveWireMode(removeWireButton) {
//             if (this.isRemoveWireMode) return;
//             this.isRemoveWireMode = true;
//             removeWireButton.classList.add('button-active');

//             this.boundHandleWireRemoval = this.handleWireRemoval.bind(this);
//             this.canvas.addEventListener('click', this.boundHandleWireRemoval);
//         }

//         handleWireRemoval(event) {
//             const wire = event.target.closest('.wire');
//             if (wire) {
//                 this.wireManager.removeWire(wire);
//             }
//             this.exitRemoveWireMode();
//         }

//         exitRemoveWireMode() {
//             this.isRemoveWireMode = false;
//             document.getElementById('remove-wire').classList.remove('button-active');
//             this.canvas.removeEventListener('click', this.boundHandleWireRemoval);
//             this.boundHandleWireRemoval = null;
//         }

//         createRemoveObjectMode(removeObjectButton) {
//             if (this.isRemoveObjectMode) return;
//             this.isRemoveObjectMode = true;
//             removeObjectButton.classList.add('button-active');

//             this.boundHandleObjectRemoval = this.handleObjectRemoval.bind(this);
//             this.canvas.addEventListener('click', this.boundHandleObjectRemoval);
//         }

//         handleObjectRemoval(event) {
//             const target = event.target.closest('.element');
//             if (target) {
//                 const wiresToRemove = [];
//                 this.wireManager.wires.forEach(wire => {
//                     if (wire.start === target || wire.end === target) {
//                         wiresToRemove.push(wire);
//                     }
//                 });

//                 wiresToRemove.forEach(wire => {
//                     this.wireManager.removeWire(wire);
//                 });

//                 this.canvas.removeChild(target);
//                 const index = this.elements.indexOf(target);
//                 if (index > -1) {
//                     this.elements.splice(index, 1);
//                 }
//             }
//             this.exitRemoveObjectMode();
//         }

//         exitRemoveObjectMode() {
//             this.isRemoveObjectMode = false;
//             document.getElementById('remove-object').classList.remove('button-active');
//             this.canvas.removeEventListener('click', this.boundHandleObjectRemoval);
//             this.boundHandleObjectRemoval = null;
//         }

//         makeDraggable(element) {
//             interact(element).draggable({
//                 modifiers: [
//                     interact.modifiers.restrictRect({
//                         restriction: this.canvasContainer,
//                         endOnly: true
//                     })
//                 ],
//                 listeners: {
//                     move: (event) => this.handleDrag(event, element)
//                 }
//             });
//         }

//         handleDrag(event, element) {
//             let x = (parseFloat(element.getAttribute('data-x')) || 0) + event.dx;
//             let y = (parseFloat(element.getAttribute('data-y')) || 0) + event.dy;

//             const elementRect = element.getBoundingClientRect();
//             const canvasRect = this.canvasContainer.getBoundingClientRect();

//             for (const other of this.elements) {
//                 if (other !== element) {
//                     const otherRect = other.getBoundingClientRect();
//                     if (
//                         elementRect.right + event.dx > otherRect.left &&
//                         elementRect.left + event.dx < otherRect.right &&
//                         elementRect.bottom + event.dy > otherRect.top &&
//                         elementRect.top + event.dy < otherRect.bottom
//                     ) {
//                         return;
//                     }
//                 }
//             }

//             if (elementRect.left + event.dx < canvasRect.left) x -= event.dx;
//             if (elementRect.top + event.dy < canvasRect.top) y -= event.dy;
//             if (elementRect.right + event.dx > canvasRect.right) x -= event.dx;
//             if (elementRect.bottom + event.dy > canvasRect.bottom) y -= event.dy;

//             element.style.transform = `translate(${x}px, ${y}px)`;
//             element.setAttribute('data-x', x);
//             element.setAttribute('data-y', y);

//             this.wireManager.wires.forEach(wire => {
//                 if (wire.start === element || wire.end === element) {
//                     this.wireManager.updateWire(wire);
//                 }
//             });
//         }

//         generateUniquePosition() {
//             let x, y;
//             let overlap;
//             do {
//                 x = Math.random() * (this.canvas.offsetWidth - 70);
//                 y = Math.random() * (this.canvas.offsetHeight - 70);
                
//                 overlap = this.isOverlapping(x, y);
//             } while (overlap); 

//             return { x, y };
//         }

//         isOverlapping(x, y) {
//             return this.elements.some(el => {
//                 const rect = el.getBoundingClientRect();
//                 const canvasRect = this.canvas.getBoundingClientRect();
//                 const elX = rect.left - canvasRect.left;
//                 const elY = rect.top - canvasRect.top;
                
//                 return Math.abs(elX - x) < 70 && Math.abs(elY - y) < 70;
//             });
//         }

//         // Метод для скачивания конфигурации с сохранением состояния
//         getNetworkConfig() {
//             this.networkConfig.objects = [];
//             this.networkConfig.wires = [];

//             this.elements.forEach((element) => {
//                 this.networkConfig.addObject(element.dataset.type, parseFloat(element.style.left), parseFloat(element.style.top), element.dataset.id, element.dataset.objectStatus);
//             });

//             this.wireManager.wires.forEach((wire) => {
//                 const wireData = {
//                     id: wire.dataset.id,
//                     startId: wire.start.dataset.id,
//                     endId: wire.end.dataset.id,
//                     cableType: wire.dataset.channelType,
//                     transmissionType: wire.dataset.transmissionType,
//                     weight: wire.dataset.weight,
//                     objectStatus: wire.dataset.objectStatus  
//                 };
//                 this.networkConfig.addWire(wireData);
//             });
//             return this.networkConfig;
//         }
//         downloadConfig() {
//             this.networkConfig.objects = [];
//             this.networkConfig.wires = [];

//             this.elements.forEach((element) => {
//                 this.networkConfig.addObject(element.dataset.type, parseFloat(element.style.left), parseFloat(element.style.top), element.dataset.id, element.dataset.objectStatus);
//             });

//             this.wireManager.wires.forEach((wire) => {
//                 const wireData = {
//                     id: wire.dataset.id,
//                     startId: wire.start.dataset.id,
//                     endId: wire.end.dataset.id,
//                     cableType: wire.dataset.channelType,
//                     transmissionType: wire.dataset.transmissionType,
//                     weight: wire.dataset.weight,
//                     objectStatus: wire.dataset.objectStatus 
//                 };
//                 this.networkConfig.addWire(wireData);
//             });

//             const json = this.networkConfig.exportToJSON();
//             const blob = new Blob([json], { type: 'application/json' });
//             const url = URL.createObjectURL(blob);
//             const a = document.createElement('a');
//             a.href = url;
//             a.download = 'network-config.json';
//             a.click();
//         }

//         loadConfig(event) {
//             const file = event.target.files[0];
//             if (!file) return;

//             const reader = new FileReader();
//             reader.onload = (e) => {
//                 const jsonData = e.target.result;
//                 const config = NetworkConfig.importFromJSON(jsonData);
//                 this.applyConfig(config);
//             };
//             reader.readAsText(file);
//         }

//         applyConfig(config) {
//             // Удаляем все текущие элементы и провода
//             this.elements.forEach(element => this.canvas.removeChild(element));
//             this.wireManager.wires.forEach(wire => {
//                 this.canvas.removeChild(wire);
//                 this.canvas.removeChild(wire.label);
//             });

//             // Очищаем массивы
//             this.elements = [];
//             this.wireManager.wires = [];

//             // Восстанавливаем объекты (станции и маршрутизаторы)
//             config.objects.forEach((obj) => {
//                 let { x, y } = obj; 
//                 while (this.isOverlapping(x, y)) {
//                     const newPosition = this.generateUniquePosition();
//                     x = newPosition.x;
//                     y = newPosition.y;
//                 }
//                 this.createElement(obj.type, x, y, obj.id, obj.objectStatus);  

//                 // Ищем созданный элемент по его ID
//                 const element = this.elements.find(el => el.dataset.id === obj.id);
//                 if (element) {
//                     element.dataset.objectStatus = obj.objectStatus;  // Восстанавливаем статус
//                     element.style.opacity = (obj.objectStatus === 'off') ? '0.5' : '1'; // Восстанавливаем видимость
//                 }
//             });

//             // Восстанавливаем провода
//             config.wires.forEach((wire) => {
//                 const startElement = this.elements.find(el => el.dataset.id === wire.startId);
//                 const endElement = this.elements.find(el => el.dataset.id === wire.endId);

//                 if (startElement && endElement) {
//                     const newWire = this.wireManager.createWire(startElement, endElement, wire.cableType, wire.transmissionType, wire.weight, wire.objectStatus);
//                 }
//             })
//         }

        
//         getRandomWeight() {
//             const weights = [3, 5, 6, 8, 10, 12, 17, 20, 25, 27];
//             return weights[Math.floor(Math.random() * weights.length)];
//         }

//         createRandomizedNetwork() {
//              // Стираем все предыдущие элементы
//             this.elements.forEach(element => this.canvas.removeChild(element));
//             this.wireManager.wires.forEach(wire => {
//                 this.canvas.removeChild(wire);
//                 this.canvas.removeChild(wire.label);
//             });
//             this.elements = [];
//             this.wireManager.wires = [];

//             // Сбрасываем счётчики
//             this.routerCounter = 0;
//             this.workstationCounter = 0;

//             // Создаем 24 роутера и сохраняем их в массив
//             const routers = [];
//             const regionWidth = 450;
//             const routerSpacingX = 250;
//             const routerSpacingY = 300;
//             const regionHeight = 300;
//             const regionY1 = 20;
//             const regionY2 = regionHeight;

//             // Массив для хранения всех связей роутеров
//             const routerConnections = Array(24).fill().map(() => []);

//             // Создаем роутеры для первого региона (первые 12 роутеров)
//             for (let i = 0; i < 12; i++) {
//                 const x = (i % 6) * routerSpacingX;
//                 const y = Math.floor(i / 6) * routerSpacingY + regionY1;
//                 const router = this.createElement('router', x, y);
//                 routers.push(router);

//                 // Создаем рабочую станцию для каждого роутера
//                 const workstationX = x + 80;
//                 const workstationY = y + 60 + Math.floor(Math.random() * 150) + 1;
//                 const workstation = this.createElement('workstation', workstationX, workstationY);

//                 // Создаем провод, соединяющий роутер с рабочей станцией
//                 this.wireManager.createWire(
//                     router, 
//                     workstation, 
//                     'default', 
//                     Math.random() < 0.5 ? 'duplex' : 'halfduplex', 
//                     this.getRandomWeight()
//                 );
//             }

//             // Создаем роутеры для второго региона (следующие 12 роутеров)
//             for (let i = 12; i < 24; i++) {
//                 const x = (i % 6) * routerSpacingX;
//                 const y = Math.floor(i / 6) * routerSpacingY + regionY2 - 50;
//                 const router = this.createElement('router', x, y);
//                 routers.push(router);

//                 // Создаем рабочую станцию для каждого роутера
//                 const workstationX = x + 80;
//                 const workstationY = y + 80 + Math.floor(Math.random() * 100) + 1;
//                 const workstation = this.createElement('workstation', workstationX, workstationY);

//                 // Создаем провод, соединяющий роутер с рабочей станцией
//                 this.wireManager.createWire(
//                     router, 
//                     workstation, 
//                     'default', 
//                     Math.random() < 0.5 ? 'duplex' : 'halfduplex', 
//                     this.getRandomWeight()
//                 );
//             }

//             // Создаем спутниковые соединения между двумя регионами
//             // Случайный роутер из первого региона
//             const randomRouter1 = routers[Math.floor(Math.random() * 12)];
//             // Случайный роутер из второго региона
//             const randomRouter2 = routers[12 + Math.floor(Math.random() * 12)];

//             // Создаем первое спутниковое соединение
//             this.wireManager.createWire(randomRouter1, randomRouter2, 'satellite', 'duplex', 27);

//             // Случайный роутер из первого региона (для второго соединения)
//             const randomRouter3 = routers[Math.floor(Math.random() * 12)];
//             // Случайный роутер из второго региона (для второго соединения)
//             const randomRouter4 = routers[12 + Math.floor(Math.random() * 12)];

//             // Создаем второе спутниковое соединение
//             this.wireManager.createWire(randomRouter3, randomRouter4, 'satellite', 'duplex', 25);

//             // Связываем роутеры внутри каждого региона (с максимальными 3 соединениями)
//             const createConnections = (regionStart, regionEnd) => {
//             for (let i = regionStart; i < regionEnd; i++) {
//                 let connections = routerConnections[i];

//                 // Ограничиваем цикл для избежания зависания
//                 let attempts = 0;
//                 const maxAttempts = 100; // Максимальное число попыток для поиска соединений

//                 while (connections.length < 3 && attempts < maxAttempts) {
//                     const targetIndex = Math.floor(Math.random() * (regionEnd - regionStart)) + regionStart;

//                     if (
//                         targetIndex !== i && 
//                         !connections.includes(targetIndex) && 
//                         routerConnections[targetIndex].length < 3
//                     ) {
//                         // Создаем соединение между роутерами
//                         this.wireManager.createWire(
//                             routers[i], 
//                             routers[targetIndex], 
//                             'default', 
//                             Math.random() < 0.5 ? 'duplex' : 'halfduplex', 
//                             this.getRandomWeight()
//                         );
//                         connections.push(targetIndex);
//                         routerConnections[targetIndex].push(i);
//                     }

//                     attempts++;
//                 }

//                 // Обрабатываем последние два блока отдельно
//                 if (i >= regionEnd - 2 && connections.length < 3) {
//                     while (connections.length < 3) {
//                         const targetIndex = (connections.length === 2) ? regionStart : Math.floor(Math.random() * (regionEnd - regionStart)) + regionStart;

//                         if (
//                             targetIndex !== i && 
//                             !connections.includes(targetIndex)
//                         ) {
//                             // Создаем принудительное соединение
//                             this.wireManager.createWire(
//                                 routers[i], 
//                                 routers[targetIndex], 
//                                 'default', 
//                                 Math.random() < 0.5 ? 'duplex' : 'halfduplex', 
//                                 this.getRandomWeight()
//                             );
//                             connections.push(targetIndex);
//                             if (!routerConnections[targetIndex].includes(i)) {
//                                 routerConnections[targetIndex].push(i);
//                             }
//                         }
//                     }
//                 }
//             }
//         };


//             // Создаем соединения внутри первого региона (первый регион)
//             createConnections(0, 12);

//             // Создаем соединения внутри второго региона (второй регион)
//             createConnections(12, 24);
//         }

//         transferDataMenuOpen() {
//             this.sideMenu.openTransferDataMenu();
//         }
//     }

//     document.addEventListener('DOMContentLoaded', () => {
//         const canvas = document.getElementById('canvas');
//         const canvasContainer = document.getElementById('canvas-container');
//         const addRouterButton = document.getElementById('add-router');
//         const addWorkstationButton = document.getElementById('add-workstation');
//         const addWireButton = document.getElementById('add-wire');
//         const removeWireButton = document.getElementById('remove-wire');
//         const removeObjectButton = document.getElementById('remove-object');
//         const uploadButtonContainer = document.getElementById('upload-config');
//         const downloadButton = document.getElementById('download-config');
//         const transferButton = document.getElementById('transfer-data');
//         const app = new NetworkApp(canvas, canvasContainer);

//         addRouterButton.addEventListener('click', () => app.createElement('router'));
//         addWorkstationButton.addEventListener('click', () => app.createElement('workstation'));
//         addWireButton.addEventListener('click', () => app.createWireMode(addWireButton));
//         removeWireButton.addEventListener('click', () => app.createRemoveWireMode(removeWireButton));
//         removeObjectButton.addEventListener('click', () => app.createRemoveObjectMode(removeObjectButton));
//         downloadButton.addEventListener('click', () => app.downloadConfig());
//         transferButton.addEventListener('click', () => app.transferDataMenuOpen());
//         document.getElementById('randomize').addEventListener('click', () => app.createRandomizedNetwork());

//         const uploadButton = document.createElement('input');
//         uploadButton.type = 'file';
//         uploadButton.classList.add('hidden');
//         uploadButton.accept = '.json';
//         uploadButton.addEventListener('change', (event) => app.loadConfig(event));

//         const uploadButtonLabel = document.createElement('button');
//         uploadButtonLabel.innerText = 'Upload Configuration';
//         uploadButtonLabel.classList.add('px-4', 'py-2', 'bg-green-500', 'text-white', 'rounded', 'shadow');
//         uploadButtonLabel.addEventListener('click', () => uploadButton.click());

//         uploadButtonContainer.appendChild(uploadButtonLabel);
//         uploadButtonContainer.appendChild(uploadButton);

//                 // Функция для отслеживания появления кнопки
//         function observeButtonCreation(app) {
//             // Создаём экземпляр MutationObserver
//             const observer = new MutationObserver((mutationsList, observer) => {
//                 // Для каждой мутации (изменения в DOM)
//                 mutationsList.forEach((mutation) => {
//                     // Проверяем, добавлен ли элемент с id "send-data-between"
//                     if (mutation.type === 'childList') {
//                         const button = document.getElementById('send-data-between');
//                         if (button) {
//                             // Если кнопка появилась, добавляем обработчик события
//                             button.addEventListener('click', () => handleSendData(app));
//                             // Прекращаем наблюдение, если кнопку уже нашли
//                             observer.disconnect();
//                         }
//                     }
//                 });
//             });

//             // Настройки для отслеживания
//             const config = { childList: true, subtree: true };

//             // Наблюдаем за body (или другим элементом контейнера)
//             observer.observe(document.body, config);
//         }

//         // Запускаем наблюдение за созданием кнопки
//         observeButtonCreation(app);

//         // Функция обработки нажатия кнопки
//         function handleSendData(app) {
//             const fromWorkstationId = document.querySelector('#from-workstation-select').value;
//             const toWorkstationId = document.querySelector('#to-workstation-select').value;
//             const dataSize = document.querySelector('#data-size').value;

//             // Пример создания экземпляра и отправки пакета
//             const packetTransfer = new PacketTransfer(app.getNetworkConfig());
//             packetTransfer.transferDataWithProtocols(fromWorkstationId, toWorkstationId, dataSize);

//             // Логика для отправки данных (например, проверка и симуляция передачи)
//             if (!fromWorkstationId || !toWorkstationId) {
//                 alert('Please select both workstations.');
//                 return;
//             }

//             // Пример обработки отправки данных
//             console.log(`Sending data from ${fromWorkstationId} to ${toWorkstationId} with size ${dataSize} MTU.`);
//         }

//     });
// </script>






    
</body>
</html>

